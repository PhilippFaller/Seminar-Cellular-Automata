\documentclass[11pt]{article}


\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
%aobs-tikz

\usepackage{amsmath}
\usepackage{mathtools}
\usepackage[standard, thref]{ntheorem}

\usepackage[tt=false]{libertine}   % !!!!! das muss man nicht nutzen
\usepackage[libertine]{newtxmath}  % !!!!! das muss man nicht nutzen
\usepackage[supstfm=libertinesups,supscaled=1.2,raised=-.13em]{superiors} % params taken from doc

%
%\usepackage{tgpagella}
%\usepackage[euler-digits]{eulervm}
%
\usepackage{microtype}

\usepackage{fancyvrb}

%\usepackage{graphicx}

\usepackage{booktabs}
\usepackage[shortlabels]{enumitem}
\setlist{noitemsep}

\usepackage{titlesec}
%\usepackage{tcolorbox}
%\tcbuselibrary{listingsutf8}

\usepackage{bbold}
\newcommand{\Z}{\mathbb{Z}}

\usepackage{csquotes}

\usepackage{xcolor}
\usepackage{beamercolorthemekit}


%-----------------------------------------------------------------------------
% für das Deckblatt

\usepackage{tikz}
\usetikzlibrary{automata}
\usetikzlibrary{chains}

\newcommand{\teilnehmername}{Philipp Faller} % !!!!!
\newcommand{\teilnehmermatrnr}{1939704}        % !!!!!
\newcommand{\seminarart}{Proseminar}           % !!!!!  oder Seminar
\newcommand{\seminarlp}{3 LP}                  % !!!!!  Prosem immer 3 LP, Sem 3 oder 4 LP
\newcommand{\seminarjahr}{2017}                % !!!!!
%-----------------------------------------------------------------------------
\newcommand{\meta}[1]{$\langle$\textit{#1}$\rangle$}
\newcommand{\paket}[1]{\texttt{#1}}
\newcommand{\prgname}[1]{\texttt{#1}}
\newcommand{\defWord}[1]{\emph{#1}}

%-----------------------------------------------------------------------------
\author{Thomas Worsch}
\title{Hinweise zu Seminarausarbeitungen}

%=============================================================================
\begin{document}
%=======================================================================
% Anfang erste Seite
{\thispagestyle{empty}\large\sffamily\raggedright
%
\begin{tikzpicture}[remember picture,overlay]
  \coordinate[xshift=5mm,yshift=-5mm] (NW) at (current page.north west) {};
  \coordinate[xshift=-5mm,yshift=-5mm] (NE) at (current page.north east) {};
  \coordinate[xshift=-5mm,yshift=13mm] (SE) at (current page.south east) {};
  \coordinate[xshift=5mm,yshift=13mm] (SW) at (current page.south west) {};

  \draw[line width=0.25pt] (NW)
    [rounded corners=5mm] -- (NE) 
    [sharp corners] -- (SE)
    [rounded corners=5mm] -- (SW)
    [sharp corners] -- cycle
  ;
\end{tikzpicture}
%
\unskip % keine Ahnung warum das nötig ist
\noindent \textbf{\Large \seminarart\ (\seminarlp)} 
\\[\baselineskip]
%
Zellularautomaten und diskrete komplexe Systeme
% für Fortgeschrittene  % nur für das 4 Leistungspunkte Seminar !!!!!
\\[1ex]
%
im Sommersemester \seminarjahr

\vspace*{3\baselineskip}

\noindent \textbf{\Large Ausarbeitung} \\[\baselineskip]
%
von \textbf{\teilnehmername}, Matr.nr.~\teilnehmermatrnr

\vspace*{3\baselineskip}

\noindent \textbf{\Large Thema} \\[\baselineskip]
%
% nachfolgende ein Beispiel, für Konferenzbeiträge, Buchausschnitte, ...
% bitte analog vorgehen !!!!!
%
Angela Wu und Azriel Rosenfeld (1979)\\[1ex]
%
\textit{Cellular Graph Automata I }\\[1ex]
%
Information and Controll, Band \textbf{42}, S.~305-329
}
\clearpage
% Ende erste Seite
%=======================================================================
% Anfang zweite Seite
{\thispagestyle{empty}\raggedright

\noindent \textbf{\Large Erklärung}\\[1ex]
gemäß \S 6 (11) der Prüfungsordnung Informatik % !!!!! oder \S 6 (7) (bei MasterPO 2015)
(Bachelor) % oder Master !!!!!
\\[\baselineskip]

\noindent
Ich versichere wahrheitsgemäß, die Seminarausarbeitung zum
\seminarart{} "`Zellularautomaten und diskrete komplexe Systeme"' im
Sommersemester \seminarjahr{} selbstständig angefertigt, alle
benutzten Hilfsmittel vollständig und genau angegeben und alles
kenntlich gemacht zu haben, was aus Arbeiten anderer unverändert oder
mit Abänderungen entnommen wurde.

\vspace*{30mm}
\noindent
\begin{tabular}{@{}l}
  \hline
   \\[-1ex]
  \hbox to 0.6\textwidth{(\teilnehmername, Matr.nr.~\teilnehmermatrnr) \hss}
\end{tabular}
}
\clearpage
% Ende zweite Seite
%=======================================================================

%-----------------------------------------------------------------------------

\section{Übersicht}

\section{$d$"=Graphen}
\begin{definition}[$d$"~Graph]
Sei $L$ eine endliche, nicht leere Menge von Beschriftungen, mit einem ausgezeichneten Element $\#$. 
Ein \defWord{$d$"~Graph} über $L$ ist ein 4"=Tupel $\Gamma = \left(N, A, f, g\right)$, wobei
\begin{itemize}
	\item[$N$] eine endliche, nicht leere Menge aus Knoten ist.
	\item[$A$] $\subseteq N \times N$ ist eine symmetrische Relation über $N$ und heißt \defWord{Kantenmenge} von $L$.
	\item[$f$] $: N \rightarrow L$  heißt \defWord{Beschriftungsfunktion}.
	\item[$g$] $: A \rightarrow Z_d$ , ist eine Abbildung, wobei $Z_d = \left \{1, 2,\text{\dots}, d \right \}$. 
\end{itemize}
Dabei muss für eine Kante $\left(n, m\right) \in A$ gelten:
\begin{align*}
f(n) = \# &\implies f(m) \neq \#
\end{align*}
Sei $A_n := \left \{\left(n, m\right) \in A\right \}$ die Menge aller Kanten, die von einem Knoten $n$ ausgehen. Dann muss außerdem noch gelten:
\begin{align*}
f(n) \neq \# &\implies  \left|A_n\right| = d \text{ und } g \vert_{A_n} \text{ ist Bijektion} \\
f(n) = \# &\implies\left|A_n\right| = 1
\end{align*}

\end{definition}

Informell ist $\Gamma$ also ein Graph, dessen Knoten mit Beschriftungen aus $L$ versehen sind. 
Jede Kante hat eine Nummer aus $\left\{1, \dots, d\right\}$. 
Dabei gilt im Allgemeinen $g(n, m) \neq g(m, n)$. 
Jeder Knoten, dessen Beschriftung nicht $\#$ ist, hat Ausgangsgrad $d$, jeder andere hat Ausgangsgrad $1$. 

%\begin{beispiel}
%	\label{dGraph}
%	\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north), auto]
%	\node[state](a){$a$};
%	\node[state](c)[below right of=a]{$c$};
%	\node[state](b)[above right of=c]{$b$};
%	\foreach \q/\p/\a/\b in {a/b/1/1, a/c/2/1, b/c/2/2}
%			\draw[->] (\q) edge[bend left=9] node {\a} (\p) 
%					  (\p) edge[bend left=9] node {\b} (\q) 
%			;
%						
%	\end{tikzpicture}
%\end{beispiel}

\begin{beispiel}
	\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north), auto]
		\node[state](a){$a$};
		\node[state](b)[right of = a]{$b$};
		\node[state](d)[right of = b]{$d$};
		\node[state](f)[below right of = d]{$f$};
		\node[state](e)[below left of = f]{$e$};
		\node[state](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](a2)[left of = c1]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q/\a/\b in {a/b/1/2, b/d/1/2, b/c/2/3, d/e/2/3, d/f/1/2, e/f/3/3, c/e/1/3, a1/a/1/1, a2/a/3/1, c1/c/1/1, f1/f/2/1}
			\draw[->] 
				(\q) edge[bend left=9] node {\a} (\p) 
				(\p) edge[bend left=9] node {\b} (\q) 			
		;
	\end{tikzpicture}
\end{beispiel}

\begin{definition}[Zugrunde liegender Graph]
	Sei $\Gamma$ ein $d$"~Graph. 
	Der \defWord{$\Gamma$ zugrunde liegende Graph $G(\Gamma) = \left(V, E\right)$} ist der Graph, mit der Knotenmenge \begin{displaymath}
		V = N\setminus \left\{n \in N \mid f(n) = \# \right\}
	\end{displaymath} und der Kantenmenge  
	\begin{displaymath}
		E = A\setminus \left\{\left(n, m\right) \in A \mid f(n) = \# \lor f(m) = \# \right\}.
	\end{displaymath} 
	$G$ ist also der Graph, der durch entfernen der Knoten, die mit $\#$ beschriftet sind, entsteht.
	Ein $d$"~Graph heißt \defWord{zusammenhängend}, wenn der zugrunde liegende Graph zusammenhängend ist.
\end{definition}

\begin{definition}[Nachbarschaft]
	Sei $\left(n, m\right) \in A$ und $g\left(n, m\right) = i$. 
	Dann heißt $m$ der \defWord{$i$"=te Nachbar von $n$}.
	Da $A$ symmetrisch ist impliziert das, dass 
	\begin{displaymath}
		\left(m, n\right) \in A \text{ und }\exists j \in Z_d : g(m, n) = j.
	\end{displaymath}
	Dann ist $n$ der $j$"=te Nachbar von $m$. 
	Definiere die Abbildung $h : N \times Z_d \rightarrow N$, so dass
	\begin{displaymath}
		 h(n, i) = m \iff g(n, m) = i.
	\end{displaymath}
\end{definition}

\section{Zellulare $d$"~Graph Automaten und Akzeptoren}

\begin{definition}[$d$"~Graph Automat]
	Ein \defWord{Zellulärer $d$"~Graph Automat} $\mathcal{M}$ ist ein Tripel $\left(\Gamma, M, H\right)$, wobei
	\begin{itemize}
		\item[$\Gamma$] ein $d$"~Graph $\left(N, A, f, g\right)$ über Menge von Beschriftungen $L$ ist.
		\item[$M$] ist ein endlicher Automat $\left(Q, \delta\right)$, dabei ist 
		\begin{itemize}
			\item[$Q$] eine endliche, nicht leere Menge von Zuständen, mit $L \subseteq Q$,
			\item[$\delta$] $\cramped{: Q \times Z_d^d \times Q^d \rightarrow \mathcal{P}\left(Q\right)}$  heißt \defWord{Zustandsübergangsfunktion}.
			
			Dabei ist $\forall z \in Z_d^d, q \in Q^d : \cramped{\delta(\#, z, q) = \{\# \}}$.
		\end{itemize}
		\item[$H$] $: N \rightarrow Z_d^d$.  
	\end{itemize}
		Für $n \in N$ heißt das Bild $H(n) = \left(t_1, \text{\dots}, t_n\right) \in Z_d^d$ \defWord{Nachbarschaftsvektor} von $n$. Es gilt: 
		\begin{displaymath}
			\forall i \in Z_d : H(n)_i = 
			\begin{dcases}
				g(h(n, i), n) & ,f(n) \neq \# \\
				1 & , f(n) = \# \\ %Warum stand statt 1 t dort? 
			\end{dcases}
		\end{displaymath}
\end{definition}

Informell ist jeder Knoten $n$ in $\Gamma$ ein endlicher Automat $M_n$, mit Startzustand $f(n) \in L$. 
(Wir sagen auch $\Gamma$ ist der \defWord{Eingabegraph} von $M$.) 
In jedem Zeitschritt liest $M_n$ die Zustände seiner Nachbarn, sowie den Nachbarschaftsvektor und wechselt dann, wie durch die Zustandsübergangsfunktion $\delta$ festgelegt, in einen anderen Zustand. 
Der Nachbarschaftsvektor sagt einem Knoten dabei, der wievielte Nachbar er selbst von seinen Nachbarn ist. 
In \thref{dGraph} ist zum Beispiel $H(a) = \left(1, 1\right)$. 
Das erlaubt einem Automaten $M_n$ den Zustand eines Nachbarn zu in Abhängigkeit davon zu betrachten, der wievielte Nachbar er von diesem Knoten ist.

\begin{beispiel}
	Das folgende Beispiel soll den Nachbarschaftsvektor veranschaulichen. 
	\par\medskip \noindent
		\begin{minipage}{0.48\textwidth}
			\centering
			\begin{tikzpicture}[node distance=3cm, baseline=(current bounding box.north), auto]
			\node[state](a){$a$};
			\node[state](c)[below right of=a]{$c$};
			\node[state](b)[above right of=c]{$b$};
			\foreach \q/\p/\a/\b in {a/b/1/1, a/c/2/1, b/c/2/2}
			\draw[->] (\q) edge[bend left=9] node {\a} (\p) 
			(\p) edge[bend left=9] node {\b} (\q) 
			;
			
			\end{tikzpicture}
		\end{minipage}
		\begin{minipage}{0.48\textwidth}
			\begin{itemize}
				\item[] H(a) = (1, 1)
				\item[] H(b) = (1, 2)
				\item[] H(c) = (2, 2)
			\end{itemize}
		\end{minipage}
	
\end{beispiel}

\begin{definition}[Konfiguration]
	Eine \defWord{Konfiguration von $\mathcal{M}$} ist eine Abbildung \hbox{$c : N \rightarrow Q$}, die jedem Knoten einen Zustand zuordnet.
	Sei $n$ ein Knoten mit Zustand $q = c(n)$ und Nachbarn $m_1 := h(n, 1), \dots, m_d := h(n, d)$. 
	Sei $q = \left( c(m_1), \dots , c(m_d)\right) \in Q^d$ der Vektor, der die Zustände der Nachbarn von $n$ enthält. 
	Der Folgezustand $c'(n)$ des Knotens $n$ ist dann gegeben durch 
	\begin{displaymath}
		c'(n) = \delta(c(n), H(n),q).
	\end{displaymath} 
	Wir sagen $\delta$ überführt $c$ in $c'$ und schreiben $c \vdash c'$.
	Wird bei der Überführung $H$ nicht benutzt, das heißt $\delta$ bildet effektiv von $Q^{d+1}$ nach $Q$ ab, so heißt $\mathcal{M}$ \defWord{Schwacher Zellularer $d$"~Graph Automat}.
\end{definition}


\begin{bemerkung}
	Ein zellularer $d$"~Graph Automat ist eine Verallgemeinerung eines endlichen zellulären Automaten, wie man am folgenden Beispiel leicht sieht. Da jedoch die Knotenmenge $N$ und die Zustandsmenge $Q$ endlich sind, ist der zellulare $d$"~Graph Automat weniger mächtig als ein allgemeiner, unendlich großer Zellularautomat.
	
	\par\medskip
	\noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\begin{scope}[start chain=1 going right,node distance=0cm]
		\node[on chain=1, draw, minimum size = 1.5cm] (a){$q_0$};
		\node[on chain=1, draw, minimum size = 1.5cm] (b){$q_1$};
		\node[on chain=1, draw, minimum size = 1.5cm] (c) {$q_2$};
		\node[on chain=1, draw, minimum size = 1.5cm]  (d) {$q_3$};
		\node[on chain=1, draw, minimum size = 1.5cm]  (e) {$q_4$};
		\node[on chain=1, draw, minimum size = 1.5cm]  (f) {$q_5$};
		\end{scope}
		\end{tikzpicture}
		
		\par\medskip
		\begin{tikzpicture}[node distance=1.5cm, baseline=(current bounding box.north), every state/.style={minimum size = 3.3em}]
		\node[state] (a) {$q_5$};
		\node[state] (b)[left of = a] {$q_4$};
		\node[state] (c)[left of = b] {$q_3$};
		\node[state] (d)[left of = c] {$q_2$};
		\node[state] (e)[left of = d] {$q_1$};
		\node[state] (f)[left of = e] {$q_0$};
		\node[state] (a1)[right of = a] {$\#$};
		\node[state] (f1)[left of = f] {$\#$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f, a/a1, f/f1}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
	\end{minipage}
	
\end{bemerkung}

\begin{definition}[Akzeptanz]
	Ein Zellularer $d$"~Graph Automat, bei dem genau ein Knoten eine ausgezeichnete Marke als Teil seines Zustandes  besitzt, heißt \defWord{Zellularer $d$"~Graph Automat mit ausgezeichnetem Knoten}.
	
	Ein \defWord{Zellularer $d$"~Graph Akzeptor} ist ein Zellularer $d$"~Graph Automat $\mathcal{M} = \left(\Gamma, M, H \right)$ mit einem ausgezeichneten Knoten, sodass $M$ ein endlicher Akzeptor $\left(L, Q, \delta, F\right)$, mit Startzuständen $L$, Zustandsmenge $Q$, Zustandsüberführungsfunktion $\delta$ und akzeptierenden Zuständen $F \subseteq Q$ ist.
	
	Eine \defWord{Startkonfiguration} von $\mathcal{M}$ ist eine beliebige Abbildung $c : N \rightarrow L$. 
	Eine \defWord{Endkonfiguration} ist eine Abbildung $c' : N \rightarrow Q$, bei der für den ausgezeichneten Knoten $\hat{n}$ gilt: 
	\begin{displaymath}
		c'(\hat{n}) \in F
	\end{displaymath} 
	Also eine Konfiguration, bei der der ausgezeichnete Knoten sich in einem akzeptierenden Zustand befindet.
	
	Ein Zellularer $d$"~Graph Akzeptor \defWord{akzeptiert} den $d$"~Graph $\Gamma$, wenn es eine endliche Folge von Konfigurationen $\left(c_i\right)_{1 \le i \le m}$ gibt, mit einer Startkonfiguration $c_0 = f$ und einer Endkonfiguration $c_m$, sodass:
	\begin{displaymath}
		c_{i} \vdash c_{i+1} \text{, für } 0 \le i < m
	\end{displaymath}
\end{definition}

\begin{definition}[Sprachen]
	Für einen gegebenen endlichen Akzeptor $M$ sei 
	\begin{displaymath}
		\mathcal{C}(M) = \left\{\mathcal{M} = \left(\Gamma, M, H\right) \mid \mathcal{M} \text{ ist $d$"~Graph Akzeptor mit ausgezeichnetem Knoten} \right\}
	\end{displaymath} 
	die \defWord{Klasse, der durch $M$ festgelegten Zellularen Graph Akzeptoren}. 
	Wenn keine Verwechslungsgefahr besteht, nennen wir $\mathcal{C}(M)$ auch den \defWord{Zellularen $d$"~Graph Akzeptor von $M$}.
	Die \defWord{Sprache von $d$"=Graphen, die durch $\mathcal{C}(M)$ akzeptiert wird} ist die Menge 
	\begin{displaymath}
		\mathcal{L}(M) = \left\{\Gamma \mid \mathcal{M} = \left(\Gamma, M, H\right) \in \mathcal{C}(M) \text{ akzeptiert } \Gamma \right\}
	\end{displaymath}
	Ein $d$"~Graph $\Gamma$ wird von $\mathcal{C}$ \defWord{akzeptiert} genau dann, wenn $\Gamma \in \mathcal{L}(M)$.
	Die Klasse aller Sprachen, die von einem (deterministischen) Zellularen $d$"~Graph Akzeptor akzeptiert wird, heißt die Klasse der (deterministischen) \defWord{$d$"~Graph Sprachen} $(D)\mathcal{C}d\mathcal{L}$. 
\end{definition}

\begin{definition}[$d$"~Graph Entscheider]
	Wir nennen eine weitere Teilmenge $R \subseteq Q$ mit 
	\begin{displaymath}
		R \cap F = \emptyset
	\end{displaymath} 
	die \defWord{ablehnenden Zustände von $M$} und schreiben $M$ als 5-Tupel $\left(L, Q, \delta, F, R\right)$.
	
	$M$ \defWord{lehnt $\Gamma$ ab}, $M$ nach endlich vielen Schritten in einer Konfiguration ist, für die gilt: 
	\begin{displaymath}
		c(n) \in R
	\end{displaymath}
	wobei $n$ der ausgezeichnete Knoten von $M$ ist.
	Weiter definieren wir : 
	\begin{displaymath}
		\mathcal{L}'(M) = \left\{\Gamma \mid \mathcal{M} = \left(\Gamma, M, H\right) \in \mathcal{C}(M) \text{ lehnt } \Gamma \text{ ab}\right\}
	\end{displaymath}
	Ein $d$"~Graph $\Gamma$ wird von $\mathcal{C}(M)$ \defWord{abgelehnt} $:\iff \Gamma \in \mathcal{L}'(M)$.
	$\mathcal{C}(M)$ \defWord{entscheidet} eine $d$"=Graphen Sprache $\mathcal{L}$ genau dann, wenn $\mathcal{C}(M)$ alle $d$"=Graphen $\Gamma \in \mathcal{L}$ akzeptiert und alle $d$"=Graphen $\Gamma \notin \mathcal{L}$ ablehnt.
	
	Dann wird $\mathcal{L}$ ein \defWord{Zellulares $d$"~Graph Prädikat} und $\mathcal{C}(M)$ ein \defWord{Zellularer $d$"~Graph Entscheider} genannt. 
	Jedes Zellulare $d$"~Graph Prädikat ist insbesondere eine $d$"~Graph Sprache.
\end{definition}

\begin{definition}[Akzeptanz zugrunde liegender Graphen]
	Für einen $d$"=Graphen $\Gamma$ bezeichen $U(\Gamma)$ den $\Gamma$ zugrunde liegenden Graphen. 
	Definiere weiter 
	\begin{displaymath}
		\mathcal{G}_L^d = \left\{\gamma \mid \gamma = U(\Gamma) \text{ für einen $d$"~Graph } \Gamma \text{ über } L\right\}
	\end{displaymath} sowie für $\gamma \in \mathcal{G}_L^d :$
	\begin{displaymath}
		 U^{-1}(\gamma) := \left\{\Gamma \mid \gamma = U\left(\Gamma\right)\right\}
	\end{displaymath}
	
	$\mathcal{C}(M)$ \defWord{akzeptiert einen knotenbeschrifteten Graphen $\gamma$}, wenn $\mathcal{C}(M)$ einen $d$"~Graph in $U^{-1}(\gamma)$ akzeptiert.
	$\mathcal{C}(M)$ akzeptiert $\gamma$ \defWord{stark}, wenn $\mathcal{C}(M)$ jeden $d$"~Graph in $U^{-1}(\gamma)$ akzeptiert.
	$\mathcal{C}(M)$ akzeptiert ein Sprache $\mathcal{L} \subset \mathcal{G}_L^d$ (stark), wenn gilt: 
	\begin{displaymath}
		\gamma \in \mathcal{L} \iff \mathcal{C}\left(M\right) \text{ akzeptiert } \gamma \text{ (stark).}
	\end{displaymath} 
	
	$\mathcal{C}(M)$ \defWord{lehnt einen knotenbeschrifteten Graphen $\gamma$ ab}, wenn $\mathcal{C}(M)$ jeden $d$"~Graph in $U^{-1}(\gamma)$ ablehnt.
	$\mathcal{C}(M)$ \defWord{entscheidet ein Prädikat} $\mathcal{L} \subset \mathcal{G}_L^d$ genau dann, wenn $\mathcal{C}(M)$ jedes $\gamma \in \mathcal{L}$  akzeptiert und jedes $\gamma \notin \mathcal{L}$ ablehnt.
	Die Entscheidung ist stark, wenn die Akzeptanz stark ist. 
\end{definition}

\begin{beispiel}
	Als Beispiel wollen wir die Klasse der Zellularen $d$"~Graph Akzeptoren konstruieren, die die Sprache $\mathcal{L} = \left\{\gamma \mid \gamma \text{ ist bipartit und zusammenhängend} \right\}$ erkennen.
	Das heißt, alle Graphen, die zusammenhängend sind und deren Knotenmenge sich in zwei disjunkte Teilmengen aufteilen lässt, sodass es keine Kanten zwischen Knoten in der selben Menge gibt.
	
	Sei also $\mathcal{M} = (\Gamma, M, H)$ ein $d$"~Graph Akzeptor mit $U(\Gamma) = \gamma$.
	Zunächst sendet der ausgezeichnete Knoten $n$ von $\Gamma$ ein Signal aus, das anzeigt, dass er zur ersten Teilmenge gehört. Jeder Nachbar von $n$ kann nicht in der selben Teilmenge liegen wie $n$, da es sonst eine Kante innerhalb dieser Teilmenge gäbe. Also sendet wiederum jeder dieser Nachbarn ein Signal, um anzuzeigen, dass sie zur zweiten Menge gehören. So verfährt jeder Knoten weiter, der eines der beiden Signale erhält. Erhält ein Knoten beide Signale gleichzeitig, kann $\gamma$ nicht bipartit sein. Also sendet dieser Knoten ein Fehlersignal aus. Erhält der ausgezeichnete Knoten dieses Signal, akzeptiert er $\gamma$ nicht. Tritt kein Fehler auf, muss der ausgezeichnete Knoten wissen, wann jeder Knoten ein Signal erhalten hat. Dies kann zum Beispiel durch die parallele Konstruktion eines Spannbaumes, wie später beschrieben, geschehen.
	
	In der folgenden Abbildung ist das Signal, dass ein Knoten sendet, wenn er zur ersten Menge gehört, blau dargestellt, das andere Signal grün. Der ausgezeichnete Knoten ist doppelt umrandet.
	
	\definecolor{S3}{named}{kit-green100}
	\definecolor{S1}{named}{kit-blue100}
	\definecolor{S2}{named}{kit-red70}	
	\begin{minipage}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, accepting, fill=S1] (a) {};
		\node[state] (b)[below of = a] {};
		\node[state] (c)[below of = b] {};
		\node[state] (d)[right of = a] {};
		\node[state] (e)[below of = d] {};
		\node[state] (f)[below of = e] {};
		
		\foreach \p/\q in {a/d, a/e, a/f, b/d, b/e, b/f, c/d, c/e, c/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, accepting, fill=S1] (a) {};
		\node[state] (b)[below of = a] {};
		\node[state] (c)[below of = b] {};
		\node[state, fill=S3] (d)[right of = a] {};
		\node[state, fill=S3] (e)[below of = d] {};
		\node[state, fill=S3] (f)[below of = e] {};
		
		\foreach \p/\q in {a/d, a/e, a/f, b/d, b/e, b/f, c/d, c/e, c/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{0.3\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, accepting, fill=S1] (a) {};
		\node[state, fill=S1] (b)[below of = a] {};
		\node[state, fill=S1] (c)[below of = b] {};
		\node[state, fill=S3] (d)[right of = a] {};
		\node[state, fill=S3] (e)[below of = d] {};
		\node[state, fill=S3] (f)[below of = e] {};
		
		\foreach \p/\q in {a/d, a/e, a/f, b/d, b/e, b/f, c/d, c/e, c/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
\end{beispiel}

\section{Graphen Eigenschaften}

\begin{definition}[Radius und Durchmesser]
	Sei $\Gamma$ ein zusammenhängender $d$"~Graph und $k$ ein Knoten von $\Gamma$ mit $f(k) \neq \#$.
	Der \defWord{Abstand zwischen zwei Knoten $m, n$ in $\Gamma$}, geschrieben $\text{dist}(m , n)$, ist die Länge der kürzesten Wege von $m$ nach $n$.
	\begin{displaymath}
	r(k) := \max_{\mathclap{f(n) \neq \#}} \text{ dist}(k, n)
	\end{displaymath}
	der \defWord{Radius von $\Gamma$ zum Zentrum $k$}.
	Sei $l$ der ausgezeichnete Knoten in $\Gamma$.
	Dann heißt $r := r(l)$ der \defWord{Radius von $\Gamma$}.
	\begin{displaymath}
		R(\Gamma) := \min_{f(n) \neq \#} r(n)
	\end{displaymath}
	 heißt der \defWord{echte Radius von $\Gamma$}.
	
	Den \defWord{Durchmesser von $\Gamma$} definieren wir als 
	\begin{displaymath}
		d(\Gamma) := \max_{f(m) \neq \# \neq f(n)} \text{dist}(m, n)
	\end{displaymath} 
	
	Je nach Position von $k$ gilt $d(\Gamma)/2 \le r\left(k\right) \le d(\Gamma).$ Und damit auch $d(\Gamma)/2 \le R(\Gamma) \le d(\Gamma)$.
	Die \defWord{Fläche von $\Gamma$} ist die Mächtigkeit der Menge $ \left\{n \in N \mid f(n) \neq \# \right\}$.
	
\end{definition}

\section{Spannbaum durch Breitensuche}
Wir konstruieren nun für einen gegebenen, zusammenhängenden $d$"~Graph $\Gamma$ mit ausgezeichnetem Knoten $b$ einen Spannbaum des zugrunde liegenden Graphen, mit der Wurzel $b$ und minimaler Höhe $h$. 
Dazu sendet $b$ ein Signal $S$ aus. Jeder Nachbar von $b$ speichert in seinem Zustand die Nummer, der Kante, die zu $b$ führt und sendet das Signal weiter. 
Jeder Knoten verarbeitet dieses Signal $S$ nur, wenn er es zum ersten Mal erhält. 
Erhält ein Knoten das Signal von zwei verschiedenen Nachbarn gleichzeitig, wählt er nach einer beliebigen aber festen Regel (z.B. immer der Nachbar, mit der niedrigsten Nummer) einen der beiden als Vorgänger aus. 
Dadurch erhalten wir von jedem Knoten $n$ einen eindeutigen Pfad zu $b$, indem wir von $n$ zu seinem Vorgänger $n_1$ und von $n_1$ zu dessen Vorgänger $n_2$ und so weiter gehen, bis wir bei $n_k=b, k \in \mathbb{N}$ angekommen sind. 
Jeder Knoten verarbeitet genau einmal das Signal. 
Und der längste Weg, den das Signal zurücklegen kann ist der Radius von $\Gamma$ zum Zentrum $b$. 
Also benötigt diese Konstruktion den Radius zum Zentrum $b$ als Zeit.

Der Baum besitzt minimale Höhe. 
Wäre das nicht der Fall, würde ein Pfad in $\Gamma$ existieren, der einen Knoten $n$ mit $b$ verbindet und kürzer ist, als der Pfad im Baum. 
Dann hätte jedoch das Signal über diesen Pfad $n$ zuerst erreicht und der andere Pfad wäre nicht in den Baum aufgenommen worden. 
Das ist ein Widerspruch.

Zusätzlich kann jeder Knoten $n$ seine Nachfolger bestimmen. 
Dazu wartet $n$, bis ein Nachbarn $m$ einen Vorgänger gewählt hat.
Da $n$ durch die Funktion $H$ weiß, der wievielte Nachbar von $m$ er ist, kann er an dessen Zustand ablesen, ob $m$ sein Nachfolger ist, oder nicht. 
Davor steht das noch nicht fest, da $m$ möglicherweise von mehreren Knoten gleichzeitig benachrichtigt wird und sich erst entscheiden muss, wer sein Vorgänger ist.

Ein Knoten $n$ erkennt, dass er ein Blatt ist daran, dass alle seine Nachbarn entweder mit $\#$ beschriftet sind, oder einen anderen Knoten als $n$ als Vorgänger gewählt haben.

Damit $b$ weiß, wann der Baum vollständig konstruiert ist, sendet jedes Blatt, ein Signal $S'$ aus, dass von seinem Vorgänger $m$ genau dann weitergeleitet wird, wenn alle Nachfolger von $m$ ihm dieses Signal gesendet haben. 
Erhält $b$ dieses Signal von allen seinen Nachfolgern, weiß $b$, dass die Konstruktion komplett ist.
Mit einem analogen Argument wie oben folgt, dass diese Konstruktion zweimal den Radius als Zeit benötigt.

%Sei Zustandsmenge $Q = \left\{N, S, S', W\right\} \times Z_d \cup \{?\} \times \mathbb{B}$. Dabei gibt die erste Komponente an, ob der Knoten unbesucht ist $N$, gerade das Signal $S$ oder $S'$ versendet, oder mit $W$ signalisiert, dass er darauf wartet $S'$ von seinen Kindern zu erhalten. In der zweiten Komponente wird die Kantennummer des Elternknotens gespeichert und in der dritte, ob es sich um den Wurzelknoten handelt. Jeder Knoten startet also mit der Beschriftung $(N, ?, \texttt{false})$, bis die Wurzel, da diese in der letzten Komponente \texttt{true} stehen hat. Damit sähe eine mögliche Zustansübergangsfunktion $\delta : Q \times Z_d^d \times Q^d \rightarrow Q$ folgendermaßen aus:
%\begin{displaymath}%
%	\delta (N, ?, true, Z_d^d, Q^d) = (S, ?, true) 
%	\delta (N, ?, false, Z_d^d, (q_1, \dots, q_d)) = (S, \min_{i \in Z_d} \{q_i \mid q_i = (S, Z_d, \mathbb{B})\}) 
%\end{displaymath}

\definecolor{S3}{named}{kit-green100}
\definecolor{S1}{named}{kit-blue100}
\definecolor{S2}{named}{kit-red70}
\begin{beispiel} 
	In der folgenden Abbildung ist das Signal $S$ rot und das Signal $S'$ grün dargestellt. 
	Ein blauer Pfeil bedeutet, dass der Knoten von dem der Pfeil ausgeht als Vorgänger gewählt hat.
	Ein Grüner Pfeil steht umgekehrt dafür, dass der Knoten als Nachfolger erkannt wurde. 
	Die blaue Färbung heißt, dass der Knoten auf das Signal $S'$ von einem seiner Nachfolger wartet.
	
	\par\medskip
	\noindent
	\begin{minipage}{\textwidth}
	\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state](a){$a$};
		\node[state, fill=S2, accepting](b)[right of = a]{$b$};
		\node[state](d)[right of = b]{$d$};
		\node[state](f)[below right of = d]{$f$};
		\node[state](e)[below left of = f]{$e$};
		\node[state](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, fill=S2](a){$a$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S2](d)[right of = b]{$d$};
		\node[state](f)[below right of = d]{$f$};
		\node[state](e)[below left of = f]{$e$};
		\node[state, fill=S2](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;		
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, fill=S3, text=white](a){$a$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S1, text=white](d)[right of = b]{$d$};
		\node[state, fill=S2](f)[below right of = d]{$f$};
		\node[state, fill=S2](e)[below left of = f]{$e$};
		\node[state, fill=S1, text=white](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b, e/d, f/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;
		\foreach \p/\q in {b/a, b/c, b/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S3] (\q) 			
		;	
		
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, fill=S3, text=white](a){$a$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S1, text=white](d)[right of = b]{$d$};
		\node[state, fill=S3, text=white](f)[below right of = d]{$f$};
		\node[state, fill=S3, text=white](e)[below left of = f]{$e$};
		\node[state, fill=S3, text=white](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b, e/d, f/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;	
		\foreach \p/\q in {b/a, b/c, b/d, d/e, d/f}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S3] (\q) 			
		;	
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, fill=S3, text=white](a){$a$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S3, text=white](d)[right of = b]{$d$};
		\node[state, fill=S3, text=white](f)[below right of = d]{$f$};
		\node[state, fill=S3, text=white](e)[below left of = f]{$e$};
		\node[state, fill=S3, text=white](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b, e/d, f/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;	
		\foreach \p/\q in {b/a, b/c, b/d, d/e, d/f}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S3] (\q) 			
		;	
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, fill=S3, text=white](a){$a$};
		\node[state, fill=S3, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S3, text=white](d)[right of = b]{$d$};
		\node[state, fill=S3, text=white](f)[below right of = d]{$f$};
		\node[state, fill=S3, text=white](e)[below left of = f]{$e$};
		\node[state, fill=S3, text=white](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b, e/d, f/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;
		\foreach \p/\q in {b/a, b/c, b/d, d/e, d/f}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S3] (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.mid), every state/.style={minimum size = 3.3em}]
		\node[state, accepting, fill=S3, text=white](b){$b$};
		\node[state, fill=S3, text=white](c)[below of = b]{$c$};
		\node[state, fill=S3, text=white](d)[right of = c]{$d$};
		\node[state, fill=S3, text=white](a)[left of = c]{$a$};
		%		\node[state](a1)[below of = a]{$\#$};
		%		\node[state](a2)[left of = a1]{$\#$};
		%		\node[state](c1)[below of = c]{$\#$};
		\node[state, fill=S3, text=white](e)[below of = d]{$e$};
		\node[state, fill=S3, text=white](f)[right of = e]{$f$};
		%		\node[state](f1)[below of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\foreach \p/\q in {a/b, d/b, c/b, e/d, f/d}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S1] (\q) 			
		;
		\foreach \p/\q in {b/a, b/c, b/d, d/e, d/f}
		\draw[->] 
		(\p) edge[bend left=9, line width = 2pt, S3] (\q) 			
		;
		
		\end{tikzpicture}	
		
	\end{minipage}
\end{beispiel}

\section{Radius bestimmen}
Der Radius $r$ eines $d$"~Graphen zum Zentrum $k$ ist die kürzeste Distanz zwischen $k$ und dem am weitesten von $k$ entfernten Knoten $n$. 
Haben wir so einen Knoten $n$ gefunden, können wir den Radius bestimmen, indem wir die Schritte zählen, die ein Signal von $k$ benötigt um $n$ zu erreichen. 
Außerdem können wir sogar sicher sein, dass wenn ein Signal $n$ erreicht hat, hat es auch alle anderen Knoten schon erreicht. 
Dies gilt natürlich nur, wenn jeder Knoten das Signal mit der selben Geschwindigkeit weiter gibt.

Gegeben sei ein Spannbaum, wie wir ihn im letzten Abschnitt konstruiert haben, mit einer Wurzel $k$. 
Der Baum hat Höhe $h$ in dem jeder Knoten seine Kinder und seinen Eltern Knoten kennt. 
Ein Knoten $n$, der das Blatt auf einem der längsten Äste ist, ist einer der am weitesten von $k$ entfernten Knoten, da unser Spannbaum aus kürzesten Wegen besteht. 
Es gilt also:
\begin{displaymath}
h = \max_{\mathclap{f\left(n\right) \neq \#}} \text{ dist}\left(k, n\right) = r(k)
\end{displaymath}
Um $n$ zu bestimmen gehen wir wie folgt vor:

Wir senden ein Signal $S_1$ von $k$ aus. Erreicht $S_1$ ein Blattknoten, sendet dieser ein Signal $S_2$ zu seinem Elternknoten. 
Erhält ein Knoten $m$ das Signal $S_2$ von einem Kind $m_1$, aber hat von einem anderen Kind $m_2$ noch kein Signal erhalten, weiß $m$, dass $m_2$ weiter entfernt liegt als $m_1$. 
Also schickt $m$ ein Signal $R$ zum Teilbaum, der bei $m_1$ startet. Dieses Signal bedeutet den Knoten, dass sie nicht auf dem längsten Ast liegen. 
Erhält $m$  von mehreren Kindern $S_2$ gleichzeitig, kann ein beliebiges Kind für den längsten Pfad ausgewählt werden, da alle den gleichen Abstand zu $m$ haben. 
Die restlichen Kinder erhalten ebenfalls das Signal $R$. 
Jeder Knoten hat also höchstens ein Kind, dem er nicht $R$ sendet. 
Es ist klar, dass das $S_2$ vom weitesten entfernten Blatt $n$ zuletzt bei $k$ ankommt. 
Damit sind also die einzigen Knoten, die nicht $R$ erhalten haben diejenigen, die auf dem Ast von $k$ nach $n$ liegen.
$k$ kann nun ein Signal entlang dieses Astes schicken, damit die Knoten wissen, dass sie Teil des längsten Astes sind.
Das benötigt zweimal $r(k)$ Zeit. Soll $k$ zusätzlich wissen, wann das Markieren beendet ist, sendet $n$ ein Signal zu $k$ zurück. Das benötigt noch einmal $r(k)$ Schritte.

Die Knoten auf diesem Pfad können wir nun als Zähler benutzen.
Dabei wird eine Ziffer pro Knoten gespeichert. Speichern wir also Zahlen zur Basis $k$, so können wir alle natürlichen Zahlen $< k^{r+1}$ darstellen. Im folgenden Speichern wir den Radius zur Basis 2. Dies funktioniert, da $\forall r \in \mathbb{N} : r < 2^{r+1}$.

Zunächst sendet $k$ ein Signal $S$ aus. Dieses Signal wird von $n$ wieder zu $k$ zurückgeschickt. Das benötigt $2r(k)$ Zeitschritte. Wir zählen also mit halber Geschwindigkeit die Schritte, die $S$ benötigt, um wieder zu $k$ zurückzukehren.

Das Zählen funktioniert nach dem Prinzip des Carry-Ripple-Addierers. 
Das niederwertigste Bit ist dabei in $k$ und das höchstwertige Bit in $n$ zu finden.
Jeder Knoten speichert zusätlich zum Summenbit ein Übertragsbit. Im ersten Schritt sendet der Knoten $k$ das Signal $S$ aus und erhöht gleichzeitig sein Summenbit auf 1. Danach inkrementiert $k$ sein Summenbit bei jedem zweiten Zeitschritt, solange bis $S$ wieder bei $k$ angekommen ist. 
Tritt ein Übertrag bei einem Knoten $m$ auf, wird dieser sofort vom Kind von $m$ in sein Summenbit übernommen und bei $m$ wieder zurückgesetzt.
Dadurch kann kein Konflikt zwischen Inkrementieren und Übertrag entstehen.
Erhält $k$ das Signal $S$ zurück, enthält der Zähler bereits $r(k)$. 
Es kann jedoch sein, dass noch nicht alle Überträge bis zum höchstwertigen Bit durch propagiert wurden. 
Damit $k$ feststellen kann, ob dieser Vorgang zu ende ist, kann $n$ zusätzlich zur Reflektion von $S$ ein Signal $S'$ senden, dass mit halber Geschwindigkeit übertragen, also von jedem Knoten erst nach einem Zeitschritt Pause weitergeleitet wird.
$S'$ benötigt dann zusätzlich $r(l) > log_2 r(k)$ Zeitschritte, nachdem $S$ wieder bei $k$ angekommen ist. 
Damit sind sicher alle Übertrage verarbeitet, bis $S'$ ankommt.

\definecolor{S}{named}{kit-green100}
\begin{beispiel}
	In der folgenden Abbildung  ist $S$ wieder grün dargestellt. Die linke Ziffer im Knoten ist das Carrybit und die rechte das Zählerbit.
	\par\medskip \noindent
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}		
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, fill=S, text=white, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering			
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state, fill=S, text=white] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$1\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state, fill=S, text=white] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state, fill=S, text=white] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state, fill=S, text=white] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state, fill=S, text=white] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$1\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state, fill=S, text=white] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$1\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state, fill=S, text=white] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state, fill=S, text=white] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state, fill=S, text=white] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	\end{minipage}
	\begin{minipage}{\textwidth}
		\centering
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S, text=white, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	
	
	\end{minipage}
\end{beispiel}

\section{Beschriftungen finden}

Wir wollen nun herausfinden, ob eine bestimmte Beschriftung $\alpha$ in unserem $d$-Graph vorhanden ist. Dazu sei wieder der Spannbaum aus dem vorletzten Abschnitt gegeben. $k$ sendet nun ein Signal $S$ aus, das an alle Knoten weitergeleitet wird. Erhält ein Knoten mit Beschriftung $\alpha$ dieses Signal, so sendet er ein Signal $S_m$ zurück, um anzuzeigen, dass $\alpha$ gefunden wurde. $S_m$ soll dabei ein dominierendes Signal sein. Das heißt, wenn ein Knoten mehrere Signale neben $S_m$ erhält, leitet er lediglich $S_m$ weiter. Hat $n$ nicht die Beschriftung $\alpha$ und erhält das Signal $S$, sendet $n$ ein weiteres Signal $S_r$ aus. Erreicht $S_r$ $k$, ohne dass zuvor ein $S_m$ eingegangen ist, weiß $k$, dass es die Beschriftung $\alpha$ nicht gibt. Denn wäre das der Fall, hätte der so beschriftete Knoten $S_m$ losgeschickt und da $n$ einen längsten Weg zu $k$ hat, wäre dieses $S_m$ spätestens gleichzeitig mit $S_r$ bei $k$ angekommen.
%-----------------------------------------------------------------------------

\end{document}
%=============================================================================
%%% Der Rest ist für meine Editor  (GNU Emacs, was sonst ;-) :
%%%
%%% Local Variables:
%%% TeX-command-default: "XPDFLaTeX"
%%% fill-column: 78
%%% TeX-master: t
%%% End:
