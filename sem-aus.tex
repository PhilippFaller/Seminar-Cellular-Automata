\documentclass[11pt]{article}


\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
%aobs-tikz

\usepackage{amsmath}
\usepackage{mathtools}
\usepackage[standard, thref]{ntheorem}

\usepackage[tt=false]{libertine}   % !!!!! das muss man nicht nutzen
\usepackage[libertine]{newtxmath}  % !!!!! das muss man nicht nutzen
\usepackage[supstfm=libertinesups,supscaled=1.2,raised=-.13em]{superiors} % params taken from doc

%
%\usepackage{tgpagella}
%\usepackage[euler-digits]{eulervm}
%
\usepackage{microtype}

\usepackage{fancyvrb}

%\usepackage{graphicx}

\usepackage{booktabs}
\usepackage[shortlabels]{enumitem}
\setlist{noitemsep}

\usepackage{titlesec}
%\usepackage{tcolorbox}
%\tcbuselibrary{listingsutf8}

\usepackage{bbold}
\newcommand{\Z}{\mathbb{Z}}

\usepackage{csquotes}

\usepackage{xcolor}
\usepackage{beamercolorthemekit}


%-----------------------------------------------------------------------------
% für das Deckblatt

\usepackage{tikz}
\usetikzlibrary{automata}

\newcommand{\teilnehmername}{Philipp Faller} % !!!!!
\newcommand{\teilnehmermatrnr}{1939704}        % !!!!!
\newcommand{\seminarart}{Proseminar}           % !!!!!  oder Seminar
\newcommand{\seminarlp}{3 LP}                  % !!!!!  Prosem immer 3 LP, Sem 3 oder 4 LP
\newcommand{\seminarjahr}{2017}                % !!!!!
%-----------------------------------------------------------------------------
\newcommand{\meta}[1]{$\langle$\textit{#1}$\rangle$}
\newcommand{\paket}[1]{\texttt{#1}}
\newcommand{\prgname}[1]{\texttt{#1}}
\newcommand{\defWord}[1]{\emph{#1}}

%-----------------------------------------------------------------------------
\author{Thomas Worsch}
\title{Hinweise zu Seminarausarbeitungen}

%=============================================================================
\begin{document}
%=======================================================================
% Anfang erste Seite
{\thispagestyle{empty}\large\sffamily\raggedright
%
\begin{tikzpicture}[remember picture,overlay]
  \coordinate[xshift=5mm,yshift=-5mm] (NW) at (current page.north west) {};
  \coordinate[xshift=-5mm,yshift=-5mm] (NE) at (current page.north east) {};
  \coordinate[xshift=-5mm,yshift=13mm] (SE) at (current page.south east) {};
  \coordinate[xshift=5mm,yshift=13mm] (SW) at (current page.south west) {};

  \draw[line width=0.25pt] (NW)
    [rounded corners=5mm] -- (NE) 
    [sharp corners] -- (SE)
    [rounded corners=5mm] -- (SW)
    [sharp corners] -- cycle
  ;
\end{tikzpicture}
%
\unskip % keine Ahnung warum das nötig ist
\noindent \textbf{\Large \seminarart\ (\seminarlp)} 
\\[\baselineskip]
%
Zellularautomaten und diskrete komplexe Systeme
% für Fortgeschrittene  % nur für das 4 Leistungspunkte Seminar !!!!!
\\[1ex]
%
im Sommersemester \seminarjahr

\vspace*{3\baselineskip}

\noindent \textbf{\Large Ausarbeitung} \\[\baselineskip]
%
von \textbf{\teilnehmername}, Matr.nr.~\teilnehmermatrnr

\vspace*{3\baselineskip}

\noindent \textbf{\Large Thema} \\[\baselineskip]
%
% nachfolgende ein Beispiel, für Konferenzbeiträge, Buchausschnitte, ...
% bitte analog vorgehen !!!!!
%
Angela Wu und Azriel Rosenfeld (1979)\\[1ex]
%
\textit{Cellular Graph Automata I }\\[1ex]
%
Information and Controll, Band \textbf{42}, S.~305-329
}
\clearpage
% Ende erste Seite
%=======================================================================
% Anfang zweite Seite
{\thispagestyle{empty}\raggedright

\noindent \textbf{\Large Erklärung}\\[1ex]
gemäß \S 6 (11) der Prüfungsordnung Informatik % !!!!! oder \S 6 (7) (bei MasterPO 2015)
(Bachelor) % oder Master !!!!!
\\[\baselineskip]

\noindent
Ich versichere wahrheitsgemäß, die Seminarausarbeitung zum
\seminarart{} "`Zellularautomaten und diskrete komplexe Systeme"' im
Sommersemester \seminarjahr{} selbstständig angefertigt, alle
benutzten Hilfsmittel vollständig und genau angegeben und alles
kenntlich gemacht zu haben, was aus Arbeiten anderer unverändert oder
mit Abänderungen entnommen wurde.

\vspace*{30mm}
\noindent
\begin{tabular}{@{}l}
  \hline
   \\[-1ex]
  \hbox to 0.6\textwidth{(\teilnehmername, Matr.nr.~\teilnehmermatrnr) \hss}
\end{tabular}
}
\clearpage
% Ende zweite Seite
%=======================================================================

%-----------------------------------------------------------------------------

\section{Übersicht}

\section{$d$"=Graphen}
\begin{definition}[$d$"~Graph]
Sei $L$ eine endliche, nicht leere Menge von Beschriftungen, mit einem ausgezeichneten Element $\#$. 
Ein \defWord{$d$"~Graph} über $L$ ist ein 4"=Tupel $\Gamma = \left(N, A, f, g\right)$, wobei
\begin{itemize}
	\item[$N$] eine endliche, nicht leere Menge aus Knoten ist.
	\item[$A$] $\subseteq N \times N$ ist eine symmetrische Relation über $N$ und heißt \defWord{Kantenmenge} von $L$.
	\item[$f$] $: N \rightarrow L$ ist eine Abbildung, sodass für $\left(m, n\right) \in A$ gilt: $f(m) = \# \implies f(n) \neq \#$. $f$  heißt \defWord{Beschriftungsfunktion}.
	\item[$g$] $: A \rightarrow Z_d$ , mit $Z_d = \left \{1, 2,\text{\dots}, d \right \}$, ist eine Abbildung, die folgende Eigenschaften besitzt:
	
	Sei $A_n := \left \{\left(n, m\right) \in A\right \}$ die Menge aller Kanten, die von einem Knoten $n \in N$ ausgehen.
	\begin{enumerate}
		\item Falls $f(n) \neq \#$, ist $\left|A_n\right| = d$ und $g \vert_{A_n}$ ($g$ eingeschränkt auf $A_n$) ist eine Bijektion zwischen $A_n$ und $Z_d$.
		\item Falls $f(n) = \#$, ist $\left|A_n\right| = 1$
	\end{enumerate}
	
\end{itemize}
\end{definition}

Informell ist $\Gamma$ also ein Graph, dessen Knoten mit Beschriftungen aus $L$ versehen sind. 
Jede Kante hat eine Nummer aus $\left\{1, \dots, d\right\}$. 
Dabei gilt im Allgemeinen $g(n, m) \neq g(m, n)$. 
Jeder Knoten, dessen Beschriftung nicht $\#$ ist, hat Grad $d$, jeder andere hat Grad $1$. 

\begin{beispiel}
	\label{dGraph}
	\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north), auto]
	\node[state](a){$a$};
	\node[state](c)[below right of=a]{$c$};
	\node[state](b)[above right of=c]{$b$};
	\foreach \q/\p/\a/\b in {a/b/1/1, a/c/2/1, b/c/2/2}
			\draw[->] (\q) edge[bend left=9] node {\a} (\p) 
					  (\p) edge[bend left=9] node {\b} (\q) 
			;
						
	\end{tikzpicture}
\end{beispiel}

\begin{beispiel}
	\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north), auto]
		\node[state](a){$a$};
		\node[state](b)[right of = a]{$b$};
		\node[state](d)[right of = b]{$d$};
		\node[state](f)[below right of = d]{$f$};
		\node[state](e)[below left of = f]{$e$};
		\node[state](c)[left of = e]{$c$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](a2)[left of = c1]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q/\a/\b in {a/b/1/2, b/d/1/2, b/c/2/3, d/e/2/3, d/f/1/2, e/f/3/3, c/e/1/3, a1/a/1/1, a2/a/3/1, c1/c/1/1, f1/f/2/1}
			\draw[->] 
				(\q) edge[bend left=9] node {\a} (\p) 
				(\p) edge[bend left=9] node {\b} (\q) 			
		;
	\end{tikzpicture}
\end{beispiel}

\begin{definition}[Zugrunde liegender Graph]
	Sei $\Gamma$ ein $d$"~Graph. 
	Der \defWord{$\Gamma$ zugrunde liegende Graph $G(\Gamma) = \left(V, E\right)$} ist der Graph, mit der Knotenmenge \begin{displaymath}
		V = N\setminus \left\{n \in N \mid f\left(n\right) = \# \right\}
	\end{displaymath} und der Kantenmenge  
	\begin{displaymath}
		E = A\setminus \left\{\left(n, m\right) \in A \mid f(n) = \# \lor f(m) = \# \right\}.
	\end{displaymath} 
	$G$ ist also der Graph, der durch entfernen der Knoten, die mit $\#$ beschriftet sind, entsteht.
	Ein $d$"~Graph heißt \defWord{zusammenhängend}, wenn der zugrunde liegende Graph zusammenhängend ist.
\end{definition}

\begin{definition}[Nachbarschaft]
	Sei $\left(n, m\right) \in A$ und $g\left(n, m\right) = i$. 
	Dann heißt $m$ der \defWord{$i$"=te Nachbar von $n$}.
	Da $A$ symmetrisch ist impliziert das, dass 
	\begin{displaymath}
		\left(m, n\right) \in A \text{ und }\exists j \in Z_d : g(m, n) = j.
	\end{displaymath}
	Dann ist $n$ der $j$"=te Nachbar von $m$. 
	Definiere die Abbildung $h : N \times Z_d \rightarrow N$, so dass
	\begin{displaymath}
		 h(n, i) = m \iff g(n, m) = i.
	\end{displaymath}
\end{definition}

\section{Zellulare $d$"~Graph Automaten und Akzeptoren}

\begin{definition}[$d$"~Graph Automat]
	Ein \defWord{Zellulärer $d$"~Graph Automat} $\mathcal{M}$ ist ein Tripel $\left(\Gamma, M, H\right)$, wobei
	\begin{itemize}
		\item[$\Gamma$] ein $d$"~Graph $\left(N, A, f, g\right)$ über einer Menge von Beschriftungen $L$ ist.
		\item[$M$]  ist ein endlicher Automat $\left(Q, \delta\right)$, mit 
		\begin{itemize}
			\item[$Q$] ist eine endliche, nicht leere Menge von Zuständen, mit $L \subseteq Q$.
			\item[$\delta$] $: Q \times Z_d^d \times Q^d \rightarrow \mathcal{P}\left(Q\right)$ ist eine Abbildung, für die gilt $\delta \left(\#, Z_d^d, Q^d\right) = \left \{\# \right \}$. $\delta$ heißt \defWord{Zustandsübergangsfunktion}.
		\end{itemize}
		\item[$H$] $: N \rightarrow Z_d^d$ ist eine Abbildung. 
		Für $n \in N$ heißt das Bild $H(n) = \left(t_1, \text{\dots}, t_n\right) \in Z_d^d$ \defWord{Nachbarschaftsvektor} von $n$. Es gilt: 
		\begin{displaymath}
			\forall i \in Z_d : H(n)_i = 
			\begin{dcases}
				g(h(n, i), n) & ,f(n) \neq \# \\
				1 & , f(n) = \# \\ %Warum stand statt 1 t dort? 
			\end{dcases}
		\end{displaymath}
	\end{itemize}
\end{definition}

Informell ist jeder Knoten $n$ in $\Gamma$ ein endlicher Automat $M_n$, mit Startzustand $f(n) \in L$. 
(Wir sagen auch $\Gamma$ ist der \defWord{Eingabegraph} von $M$.) 
In jedem Zeitschritt liest $M_n$ die Zustände seiner Nachbarn, sowie den Nachbarschaftsvektor und wechselt dann, wie durch die Zustandsübergangsfunktion $\delta$ festgelegt, in einen anderen Zustand. 
Der Nachbarschaftsvektor sagt einem Knoten dabei, der wievielte Nachbar er selbst von seinen Nachbarn ist. 
In \thref{dGraph} ist zum Beispiel $H(a) = \left(1, 1\right)$. 
Das erlaubt einem Automaten $M_n$ den Zustand eines Nachbarn zu in Abhängigkeit davon zu betrachten, der wievielte Nachbar er von diesem Knoten ist.

\begin{definition}[Konfiguration]
	Eine \defWord{Konfiguration von $\mathcal{M}$} ist eine Abbildung \hbox{$c : N \rightarrow Q$}, die jedem Knoten einen Zustand zuordnet.
	Sei $n$ ein Knoten mit Zustand $q = c(n)$ und Nachbarn $m_1, \dots, m_d$. 
	Sei $q_m = \left( c(m_1), \dots , c(m_d)\right) \in Q^d$ der Vektor, der die Zustände der Nachbarn von $n$ enthält. 
	Der Folgezustand $c'(n)$ des Knotens $n$ ist dann gegeben durch 
	\begin{displaymath}
		c'(n) = \delta(q, H(n),q_m ).
	\end{displaymath} 
	Wir sagen $\delta$ überführt $c$ in $c'$ und schreiben $c \vdash c'$.
	Wird bei der Überführung $H$ nicht benutzt, das heißt $\delta$ bildet effektiv von $Q^{d+1}$ nach $Q$ ab, so heißt $\mathcal{M}$ \defWord{Schwacher Zellularer $d$"~Graph Automat}.
\end{definition}


\begin{bemerkung}
	Ein zellularer $d$"~Graph Automat ist eine Verallgemeinerung eines endlichen zellulären Automaten, da, falls $\Gamma$ ein regelmäßiges Gitter als zugrunde liegenden Graph besitzt, der Automat effektiv aus einem Gitter $R = G(\Gamma)$, der endlichen Zustandsmenge $Q$, der lokalen Zustandsübergangsfunktion $\delta$, sowie der Nachbarschaft $H$ besteht.
\end{bemerkung}

\begin{definition}[Akzeptanz]
	Ein Zellularer $d$"~Graph Automat, bei dem genau ein Knoten eine ausgezeichnete Marke als Teil seines Zustandes  besitzt, heißt \defWord{Zellularer $d$"~Graph Automat mit ausgezeichnetem Knoten}.
	
	Ein \defWord{Zellularer $d$"~Graph Akzeptor} ist ein Zellularer $d$"~Graph Automat $\mathcal{M} = \left(\Gamma, M, H \right)$ mit einem ausgezeichneten Knoten, sodass $\mathcal{M}$ ein endlicher Akzeptor $\left(L, Q, \delta, F\right)$, mit Startzuständen $L$, Zustandsmenge $Q$, Zustandsüberführungsfunktion $\delta$ und akzeptierenden Zuständen $F \subseteq Q$ ist.
	
	Eine \defWord{Startkonfiguration} von $\mathcal{M}$ ist eine beliebige Abbildung $c : N \rightarrow L$. 
	Eine \defWord{Endkonfiguration} ist eine Abbildung $c' : N \rightarrow Q$, bei der für den ausgezeichneten Knoten $\hat{n}$ gilt: 
	\begin{displaymath}
		c'(\hat{n}) \in F
	\end{displaymath} 
	Also eine Konfiguration, bei der der ausgezeichnete Knoten sich in einem akzeptierenden Zustand befindet.
	
	Ein Zellularer $d$"~Graph Akzeptor \defWord{akzeptiert} den $d$"~Graph $\Gamma$, wenn es eine endliche Folge von Konfigurationen $\left(c_i\right)_{1 \le i \le m}$ gibt, mit einer Startkonfiguration $c_0 = f$ und einer Endkonfiguration $c_m$, sodass:
	\begin{displaymath}
		c_{i} \vdash c_{i+1} \text{, für } 0 \le i < m
	\end{displaymath}
\end{definition}

\begin{definition}[Sprachen]
	Für einen gegebenen endlichen Akzeptor $M$ sei 
	\begin{displaymath}
		\mathcal{C}(M) = \left\{\mathcal{M} = \left(\Gamma, M, H\right) \mid \mathcal{M} \text{ ist $d$"~Graph Akzeptor mit ausgezeichnetem Knoten} \right\}
	\end{displaymath} 
	die \defWord{Klasse, der durch $M$ festgelegten Zellularen Graph Akzeptoren}. 
	Wenn keine Verwechslungsgefahr besteht, nennen wir $\mathcal{C}(M)$ auch den \defWord{Zellularen $d$"~Graph Akzeptor von $M$}.
	Die \defWord{Sprache von $d$"=Graphen, die durch $\mathcal{C}(M)$ akzeptiert wird} ist die Menge 
	\begin{displaymath}
		\mathcal{L}(M) = \left\{\Gamma \mid \mathcal{M} = \left(\Gamma, M, H\right) \in \mathcal{C}(M) \text{ akzeptiert } \Gamma \right\}
	\end{displaymath}
	Ein $d$"~Graph $\Gamma$ wird von $\mathcal{C}$ \defWord{akzeptiert} genau dann, wenn $\Gamma \in \mathcal{L}(M)$.
	Die Klasse aller Sprachen, die von einem (deterministischen) Zellularen $d$"~Graph Akzeptor akzeptiert wird, heißt die Klasse der (deterministischen) \defWord{$d$"~Graph Sprachen} $(D)\mathcal{C}d\mathcal{L}$. 
\end{definition}

\begin{definition}[$d$"~Graph Entscheider]
	Wenn $M$ eine weiter Teilmenge $R \subseteq Q$ mit $R \cap F = \emptyset$ besitzt, nennen wir diese die \defWord{ablehnenden Zustände} von $M = \left(L, Q, \delta, F, R\right)$ und schreiben $M$ als 5-Tupel.
	
	$M$ \defWord{lehnt $\Gamma$ ab}, wenn der Automat $M_n$ am ausgezeichneten Knoten $n$ nach endlich vielen Schritten in einem ablehnenden Zustand ist.
	Sei  $\mathcal{L}'\left(M\right) = \left\{\Gamma \mid \mathcal{M} = \left(\Gamma, M, H\right) \in \mathcal{C}\left(M\right) \text{ lehnt } \Gamma \text{ ab}\right\}$.
	
	Ein $d$"~Graph $\Gamma$ wird von $\mathcal{C}$ \defWord{abgelehnt} $:\iff \Gamma \in \mathcal{L}'\left(M\right)$.
	
	$\mathcal{C}\left(M\right)$ \defWord{entscheidet} eine $d$"=Graphen Sprache $\mathcal{L} \iff \mathcal{C}\left(M\right)$ akzeptiert alle $d$"=Graphen $\Gamma \in \mathcal{L} \land \mathcal{C}\left(M\right)$ lehnt alle $d$"=Graphen $\Gamma \notin \mathcal{L}$ ab.
	
	$\mathcal{L}$ wird ein \defWord{Zellulares $d$"~Graph Prädikat} und $\mathcal{C}\left(M\right)$ ein \defWord{Zellularer $d$"~Graph Entscheider} genannt. 
	Jedes Zellulare $d$"~Graph Prädikat ist insbesondere eine $d$"~Graph Sprache.
\end{definition}

\begin{definition}[Akzeptanz zugrunde liegender Graphen]
	Für einen $d$"=Graphen $\Gamma$ bezeichen $U\left(\Gamma\right)$ den $\Gamma$ zugrunde liegenden Graphen. 
	Definiere weiter $\mathcal{G}_L^d = \left\{\gamma \mid \gamma = U\left(\Gamma\right) \text{ für einen $d$"~Graph } \Gamma \text{ über } L\right\}$, sowie für $\gamma \in \mathcal{G}_L^d : U^{-1}\left(\gamma\right) := \left\{\Gamma \mid \gamma = U\left(\Gamma\right)\right\}$.
	
	$\mathcal{C}\left(M\right)$ \defWord{akzeptiert einen knotenbeschrifteten Graphen $\gamma$}, wenn $\mathcal{C}\left(M\right)$ einen $d$"~Graph in $U^{-1}\left(\gamma\right)$ akzeptiert.
	$\mathcal{C}\left(M\right)$ akzeptiert $\gamma$ \defWord{stark}, wenn $\mathcal{C}\left(M\right)$ jeden $d$"~Graph in $U^{-1}\left(\gamma\right)$ akzeptiert.
	$\mathcal{C}\left(M\right)$ akzeptiert ein Sprache $\mathcal{L} \subset \mathcal{G}_L^d$ (stark), wenn $\gamma \in \mathcal{L} \iff \mathcal{C}\left(M\right)$ akzeptiert $\gamma$ (stark). 
	
	$\mathcal{C}\left(M\right)$ \defWord{lehnt einen knotenbeschrifteten Graphen $\gamma$ ab}, wenn $\mathcal{C}\left(M\right)$ jeden $d$"~Graph in $U^{-1}\left(\gamma\right)$ ablehnt.
	$\mathcal{C}\left(M\right)$ \defWord{entscheidet ein Prädikat} $\mathcal{L} \subset \mathcal{G}_L^d :\iff \mathcal{C}\left(M\right)$ akzeptiert jedes $\gamma \in \mathcal{L}$ und $\mathcal{C}\left(M\right)$ lehnt jedes $\gamma \notin \mathcal{L}$ ab.
	Die Entscheidung ist stark, wenn die Akzeptanz stark ist. 
\end{definition}

\section{Graphen Eigenschaften}

\begin{definition}[Radius und Durchmesser]
	Sei $\Gamma$ ein zusammenhängender $d$"~Graph und $k$ ein Knoten von $\Gamma$ mit $f\left(k\right) \neq \#$.
	Der \defWord{Abstand zwischen zwei Knoten $m, n$ in $\Gamma$}, geschrieben $\text{dist}\left(m , n\right)$, ist die Länge des kürzesten Weges von $m$ nach $n$.
	$r\left(k\right) := \max_{n \in N : f\left(n\right) \neq \#} \text{dist}\left(k, n\right)$ ist der \defWord{Radius von $\Gamma$ vom Zentrum $k$ aus}.
	Sei $D$ der ausgezeichnete Knoten in $\Gamma$.
	Dann heißt $r := r\left(D\right)$ der \defWord{Radius von $\Gamma$}.
	$R\left(\Gamma\right) := \min_{k \in N : f\left(k\right) \neq \#} r\left(k\right)$ heißt der \defWord{echte Radius von $\Gamma$}.
	
	Der \defWord{Durchmesser von $\Gamma$} $d\left(\Gamma\right) := \max_{m, n \in N : f\left(m\right) \neq \# \neq f\left(n\right)} \text{dist}\left(m, n\right)$. Je nach Position von $k$ gilt $\frac{\text{Durchmesser}}{2} \le r\left(k\right) \le \text{Durchmesser}.$ Und damit gilt auch $\frac{d\left(\Gamma\right)}{2} \le R\left(\Gamma\right) \le d\left(\Gamma\right)$.
	Die \defWord{Fläche von $\Gamma$} ist die Mächtigkeit der Menge $ \left\{n \in N \mid f\left(n\right) \neq \# \right\}$.
	
\end{definition}

\section{Spannbaum durch Breitensuche}
Wir konstruieren nun für einen gegebenen $d$"~Graph $\Gamma$ mit ausgezeichnetem Knoten $b$ einen Spannbaum, des zugrunde liegenden Graphen, mit der Wurzel $b$ und minimaler Höhe. 
Dazu sendet $b$ ein Signal $S$ aus. Jeder Nachbar von $b$ speichert in seinem Zustand die Nummer, der Kante, die zu $b$ führt und sendet das Signal weiter. 
Jeder Knoten verarbeitet dieses Signal $S$ nur, wenn er es zum ersten Mal erhält. 
Erhält ein Knoten das Signal von zwei verschiedenen Nachbarn gleichzeitig, wählt er nach einer beliebigen aber festen Regel (z.B. immer der Nachbar, mit der niedrigsten Nummer) einen der beiden als Vorgänger aus. 
Dadurch erhalten wir von jedem Knoten $n$ einen eindeutigen Pfad zu $b$, indem wir von $n$ zu seinem Vorgänger $n_1$ und von $n_1$ zu dessen Vorgänger $n_2$ und so weiter gehen, bis wir bei $n_k=b, k \in \mathbb{N}$ angekommen sind. 
Jeder Knoten verarbeitet genau einmal das Signal. 
Und der längste Weg, den das Signal zurücklegen kann ist der Radius von $\Gamma$ zum Zentrum $b$. 
Also benötigt diese Konstruktion den Radius zum Zentrum $b$ als Zeit.

Der Baum besitzt minimale Höhe. 
Wäre das nicht der Fall, würde ein Pfad in $\Gamma$ existieren, der einen Knoten $n$ mit $b$ verbindet und kürzer ist, als der Pfad im Baum. 
Dann hätte jedoch das Signal über diesen Pfad $n$ zuerst erreicht und der andere Pfad wäre nicht in den Baum aufgenommen worden. 
Das ist ein Widerspruch.

Zusätzlich kann jeder Knoten $n$ seine Nachfolger bestimmen. 
Dazu wartet $n$, bis ein Nachbarn $m$ einen Vorgänger gewählt hat.
Da $n$ durch die Funktion $H$ weiß, der wievielte Nachbar von $m$ er ist, kann er an dessen Zustand ablesen, ob $m$ sein Nachfolger ist, oder nicht. 
Davor steht das noch nicht fest, da $m$ möglicherweise von mehreren Knoten gleichzeitig benachrichtigt wird und sich erst entscheiden muss, wer sein Vorgänger ist.

Damit $b$ weiß, wann der Baum vollständig konstruiert ist, sendet jedes Blatt, ein Signal $S'$ aus, dass von seinem Vorgänger $m$ genau dann weitergeleitet wird, wenn alle Nachfolger von $m$ ihm dieses Signal gesendet haben. 
Erhält $b$ dieses Signal von allen seinen Nachfolgern, weiß $b$, dass die Konstruktion komplett ist.
Mit einem analogen Argument wie oben folgt, dass diese Konstruktion zweimal den Radius als Zeit benötigt.

Sei Zustandsmenge $Q = \left\{N, S, S', W\right\} \times Z_d \cup \{?\} \times \mathbb{B}$. Dabei gibt die erste Komponente an, ob der Knoten unbesucht ist $N$, gerade das Signal $S$ oder $S'$ versendet, oder mit $W$ signalisiert, dass er darauf wartet $S'$ von seinen Kindern zu erhalten. In der zweiten Komponente wird die Kantennummer des Elternknotens gespeichert und in der dritte, ob es sich um den Wurzelknoten handelt. Jeder Knoten startet also mit der Beschriftung $(N, ?, \texttt{false})$, bis die Wurzel, da diese in der letzten Komponente \texttt{true} stehen hat. Damit sähe eine mögliche Zustansübergangsfunktion $\delta : Q \times Z_d^d \times Q^d \rightarrow Q$ folgendermaßen aus:
%\begin{displaymath}%
%	\delta (N, ?, true, Z_d^d, Q^d) = (S, ?, true) 
%	\delta (N, ?, false, Z_d^d, (q_1, \dots, q_d)) = (S, \min_{i \in Z_d} \{q_i \mid q_i = (S, Z_d, \mathbb{B})\}) 
%\end{displaymath}

\definecolor{S3}{named}{kit-green100}
\definecolor{S1}{named}{kit-blue100}
\definecolor{S2}{named}{kit-red70}
\begin{beispiel}
	
	\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state](a){$a\mid ?$};
		\node[state, fill=S2, accepting](b)[right of = a]{$b$};
		\node[state](d)[right of = b]{$d\mid ?$};
		\node[state](f)[below right of = d]{$f\mid ?$};
		\node[state](e)[below left of = f]{$e\mid ?$};
		\node[state](c)[left of = e]{$c\mid ?$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
			\draw[->] 
				(\q) edge[bend left=9] (\p)
				(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S2](a){$a\mid b$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S2](d)[right of = b]{$d\mid b$};
		\node[state](f)[below right of = d]{$f\mid ?$};
		\node[state](e)[below left of = f]{$e\mid ?$};
		\node[state, fill=S2](c)[left of = e]{$c\mid b$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
			\draw[->] 
				(\q) edge[bend left=9] (\p)
				(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		\newline
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S3](a){$a\mid b$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S1, text=white](d)[right of = b]{$d\mid b$};
		\node[state, fill=S2](f)[below right of = d]{$f\mid d$};
		\node[state, fill=S2](e)[below left of = f]{$e\mid d$};
		\node[state, fill=S1, text=white](c)[left of = e]{$c\mid b$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
			\draw[->] 
				(\q) edge[bend left=9] (\p)
				(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		\newline
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S3, text=white](a){$a\mid b$};
		\node[state, fill=S1, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S3, text=white](d)[right of = b]{$d\mid b$};
		\node[state, fill=S3, text=white](f)[below right of = d]{$f\mid d$};
		\node[state, fill=S3, text=white](e)[below left of = f]{$e\mid d$};
		\node[state, fill=S3, text=white](c)[left of = e]{$c\mid b$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		\newline
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S3, text=white](a){$a\mid b$};
		\node[state, fill=S3, text=white, accepting](b)[right of = a]{$b$};
		\node[state, fill=S3, text=white](d)[right of = b]{$d\mid b$};
		\node[state, fill=S3, text=white](f)[below right of = d]{$f\mid d$};
		\node[state, fill=S3, text=white](e)[below left of = f]{$e\mid d$};
		\node[state, fill=S3, text=white](c)[left of = e]{$c\mid b$};
		\node[state](a1)[left of = a]{$\#$};
		\node[state](a2)[below left of = a]{$\#$};
		\node[state](c1)[left of = c]{$\#$};
		\node[state](f1)[right of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, e/f, c/e, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		\newline
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting](b){$b$};
		\node[state](c)[below of = b]{$c\mid b$};
		\node[state](d)[right of = c]{$d\mid b$};
		\node[state](a)[left of = c]{$a\mid b$};
		\node[state](a1)[below of = a]{$\#$};
		\node[state](a2)[left of = a1]{$\#$};
		\node[state](c1)[below of = c]{$\#$};
		\node[state](e)[right of = c1]{$e\mid d$};
		\node[state](f)[right of = e]{$f\mid d$};
		\node[state](f1)[below of = f]{$\#$};
		
		
		\foreach \p/\q in {a/b, b/d, b/c, d/e, d/f, a1/a, a2/a, c1/c, f1/f}
		\draw[->] 
		(\q) edge[bend left=9] (\p)
		(\p) edge[bend left=9] (\q) 			
		;
		\end{tikzpicture}
		
\end{beispiel}

\section{Radius bestimmen}
Der Radius $r$ eines $d$"~Graphen zum Zentrum $k$ ist die kürzeste Distanz zwischen $k$ und dem am weitesten von $k$ entfernten Knoten $n$. 
Haben wir so einen Knoten $n$ gefunden, können wir den Radius bestimmen, indem wir die Schritte zählen, die ein Signal von $k$ benötigt um $n$ zu erreichen. 
Außerdem können wir sogar sicher sein, dass wenn ein Signal $n$ erreicht hat, hat es auch alle anderen Knoten schon erreicht. 
Dies gilt natürlich nur, wenn jeder Knoten das Signal mit der selben Geschwindigkeit weiter gibt.

Gegeben sei ein Spannbaum, wie wir ihn im letzten Abschnitt konstruiert haben, mit einer Wurzel $k$. 
Der Baum hat Höhe $r$ und jeder Knoten kennt seine Kinder und seinen Eltern Knoten. 
Ein Knoten $n$, der das Blatt auf einem längsten Ast ist, ist der am weitesten von $k$ entfernte Knoten, da unser Spannbaum aus kürzesten Wegen besteht. 
Um $n$ zu bestimmen gehen wir wie folgt vor:

Wir senden ein Signal $S_1$ von $k$ aus. Erreicht $S_1$ ein Blattknoten, sendet dieser ein Signal $S_2$ zu seinem Elternknoten. Erhält ein Knoten $m$ das $S_2$ von einem Kind $m_1$, aber hat von einem anderen Kind $m_"$ noch kein Signal erhalten, weiß $m$, dass $m_2$ weiter entfernt liegt als $m_1$. 
Also schickt $m$ ein Signal $R$ zum Teilbaum, der bei $m_1$ startet. Dieses Signal bedeutet den Knoten, dass sie nicht auf dem längsten Ast liegen. 
Erhält $m$  von mehreren Kindern $S_2$ gleichzeitig, kann ein beliebiges Kind für den längsten Pfad ausgewählt werden, da alle den gleichen Abstand zu $m$ haben. 
Die restlichen Kinder erhalten ebenfalls das Signal $R$. 
Jeder Knoten hat also höchstens ein Kind, dem er nicht $R$ sendet. 
Es ist klar, dass das $S_2$ vom weitesten entfernten Blatt $n$ zuletzt bei $k$ ankommt. 
Damit sind also die einzigen Knoten, die nicht $R$ erhalten haben diejenigen, die auf dem Ast von $k$ nach $n$ liegen.
$k$ kann nun ein Signal entlang dieses Astes schicken, damit die Knoten wisse, dass sie Teil des längsten Astes sind.
Das benötigt zweimal $r$ Zeit. Soll $k$ zusätzlich wissen, wann das markieren beendet ist, sendet $n$ ein Signal zu $k$ zurück. Das benötigt noch einmal $r$ Schritte.

Die Knoten auf diesem Pfad können wir nun als Zähler benutzen.
Dabei wird eine Ziffer pro Knoten gespeichert. Speichern wir also Zahlen zur Basis $k$, so können wir alle natürlichen Zahlen $< k^{r+1}$ darstellen. Im folgenden Speichern wir den Radius zur Basis 2. Dies funktioniert, da $r < 2^{r+1} , \forall r \geq 0$.

Zunächst sendet $k$ ein Signal $S$ aus. Dieses Signal wird von $n$ wieder zu $k$ zurückgeschickt. Das benötigt $2r$ Zeitschritte. Wir zählen also mit halber Geschwindigkeit die Schritte, die $S$ benötigt, um wieder zu $k$ zurückzukehren.

Das Zählen funktioniert nach dem Prinzip des Carry-Ripple-Addierers. 
Das LSB ist dabei in $k$ und das MSB in $n$ zu finden.
Dazu speichert jeder Knoten zwei Bit. Ein Übertragsbit und ein Summenbit. Im ersten Schritt sendet der Knoten $k$ $S$ aus und erhöht gleichzeitig sein Summenbit auf 1. Danach inkrementiert $k$ sein Summenbit bei jedem zweiten Zeitschritt, solange bis $S$ wieder bei $k$ angekommen ist. 
Tritt ein Übertrag bei einem Knoten $m$ auf, wird dieser sofort vom Kind von $m$ in sein Summenbit übernommen und bei $m$ wieder zurückgesetzt.
Dadurch kann kein Konflikt zwischen Inkrementieren und Übertrag entstehen.
Erhält $k$ das Signal $S$ zurück, enthält der Zähler bereits $r$. 
Es kann jedoch sein, dass noch nicht alle Überträge bis zum höchstwertigen Bit durch propagiert wurden. 
Damit $k$ feststellen kann, ob dieser Vorgang zu ende ist, kann $n$ zusätzlich zur Reflektion von $S$ ein Signal $S'$ senden, dass mit halber Geschwindigkeit übertragen, also von jedem Knoten erst nach einem Zeitschritt Pause weitergeleitet wird.
$S'$ benötigt dann zusätzlich $r > log_2 r$ Zeitschritte, nachdem $S$ wieder bei $k$ angekommen ist. 
Damit sind sicher alle Übertrage verarbeitet, bis $S'$ ankommt.

\definecolor{S}{named}{kit-green100}
\begin{beispiel}
	\begin{figure}[h]
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}		
	
		\begin{tikzpicture}[node distance=2cm, baseline=(current bounding box.north)]
		\node[state, fill=S, text=white, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state, fill=S, text=white] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$1\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state, fill=S, text=white] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state, fill=S, text=white] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state, fill=S, text=white] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state, fill=S, text=white] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$1\mid 0$};
		\node[state] (b)[left of = a] {$0\mid 1$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state, fill=S, text=white] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 0$};
		\node[state] (b)[left of = a] {$1\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 0$};
		\node[state, fill=S, text=white] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state, fill=S, text=white] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, accepting] (a) {$0\mid 1$};
		\node[state, fill=S, text=white] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
		
		\begin{tikzpicture}[node distance=2cm]
		\node[state, fill=S, text=white, accepting] (a) {$0\mid 1$};
		\node[state] (b)[left of = a] {$0\mid 0$};
		\node[state] (c)[left of = b] {$0\mid 1$};
		\node[state] (d)[left of = c] {$0\mid 0$};
		\node[state] (e)[left of = d] {$0\mid 0$};
		\node[state] (f)[left of = e] {$0\mid 0$};
		
		\foreach \p/\q in {a/b, b/c, c/d, d/e, e/f}
		\draw[->] 
		(\q) edge (\p)
		(\p) edge (\q) 			
		;
		\end{tikzpicture}
	
	
	\end{figure}
\end{beispiel}

\section{Beschriftungen finden}

Wir wollen nun herausfinden, ob eine bestimmte Beschriftung $\alpha$ in unserem $d$-Graph vorhanden ist. Dazu sei wieder der Spannbaum aus dem vorletzten Abschnitt gegeben. $k$ sendet nun ein Signal $S$ aus, das an alle Knoten weitergeleitet wird. Erhält ein Knoten mit Beschriftung $\alpha$ dieses Signal, so sendet er ein Signal $S_m$ zurück, um anzuzeigen, dass $\alpha$ gefunden wurde. $S_m$ soll dabei ein dominierendes Signal sein. Das heißt, wenn ein Knoten mehrere Signale neben $S_m$ erhält, leitet er lediglich $S_m$ weiter. Hat $n$ nicht die Beschriftung $\alpha$ und erhält das Signal $S$, sendet $n$ ein weiteres Signal $S_r$ aus. Erreicht $S_r$ $k$, ohne dass zuvor ein $S_m$ eingegangen ist, weiß $k$, dass es die Beschriftung $\alpha$ nicht gibt. Denn wäre das der Fall, hätte der so beschriftete Knoten $S_m$ losgeschickt und da $n$ einen längsten Weg zu $k$ hat, wäre dieses $S_m$ spätestens gleichzeitig mit $S_r$ bei $k$ angekommen.
%-----------------------------------------------------------------------------

\end{document}
%=============================================================================
%%% Der Rest ist für meine Editor  (GNU Emacs, was sonst ;-) :
%%%
%%% Local Variables:
%%% TeX-command-default: "XPDFLaTeX"
%%% fill-column: 78
%%% TeX-master: t
%%% End:
